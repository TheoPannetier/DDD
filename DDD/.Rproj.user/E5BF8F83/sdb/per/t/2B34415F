{
    "collab_server" : "",
    "contents" : "dd_LR = function(             \n   brts,\n   initparsoptDD,\n   initparsoptCR,\n   missnumspec,   \n   outputfilename = NULL,\n   seed = 42,\n   endmc = 1000,\n   alpha = 0.05,\n   plotit = TRUE,\n   res = 10 * (1 + length(brts) + missnumspec),\n   ddmodel = 1,\n   cond = 1,\n   btorph = 1,\n   soc = 2,\n   tol = c(1E-3,1E-4,1E-6),\n   maxiter = 2000,\n   changeloglikifnoconv = FALSE,\n   optimmethod = 'subplex',\n   methode = 'analytical'   \n   )\n{\n  if(!is.null(seed))\n  {\n     set.seed(roundn(seed))\n  }\n  age = max(brts)\n  cat(\"Estimating parameters under the constant-rate model ...\\n\")  \n  outCRO = dd_ML(brts = brts,initparsopt = initparsoptCR,idparsopt = 1:2,idparsfix = 3,parsfix = Inf,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n  cat(\"Estimating parameters under the diversity-dependent model ...\\n\")  \n  outDDO = dd_ML(brts = brts,initparsopt = initparsoptDD,idparsopt = 1:3,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n  LRO = outDDO$loglik - outCRO$loglik\n  out = cbind(NA,NA,outCRO,outDDO,NA,NA,NA,NA,NA,LRO)\n  out = out[,-c(5,7,13)]\n  newnames = c(\"model\",\"mc\",\"lambda_CR\",\"mu_CR\",\"LL_CR\",\"conv_CR\",\"lambda_DD1\",\"mu_DD1\",\"K_DD1\",\"LL_DD1\",\"conv_DD1\",\"lambda_DD2\",\"mu_DD2\",\"K_DD2\",\"LL_DD2\",\"conv_DD2\",\"LR\")\n  names(out) = newnames\n  if(!is.null(outputfilename))\n  {\n      save(seed,brts,out,file = outputfilename)\n  }\n  parsCR = as.numeric(outCRO[1:2])\n  parsDD = as.numeric(outDDO[1:3])\n  treeCR = list()\n  treeDD = list()\n  cat('Simulating trees under CR and DD models ...\\n')\n  for(mc in 1:endmc)\n  {\n     treeCR[[mc]] = dd_sim(pars = c(parsCR,Inf),age = age,ddmodel = 1)\n     treeDD[[mc]] = dd_sim(pars = parsDD,age = age,ddmodel = 1)\n  }\n  if(!is.null(outputfilename))\n  {\n      save(seed,brts,out,treeCR,treeDD,file = outputfilename)\n  }\n  cat('Performing bootstrap to determine critical LR ...\\n')  \n  for(mc in 1:endmc)\n  {\n     cat('Analyzing simulation:',mc,'\\n')\n     brtsCR = branching.times(treeCR[[mc]][[1]])\n     outCR = dd_ML(brtsCR,initparsopt = parsCR,idparsopt = 1:2,idparsfix = 3,parsfix = Inf,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     outDD1 = dd_ML(brtsCR,initparsopt = parsDD,idparsopt = 1:3,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     outDD2 = dd_ML(brtsCR,initparsopt = c(parsCR + 0.05,length(brts) + 1000),idparsopt = 1:3,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     if(outDD1$conv == -1 & outDD2$conv == -1)\n     {\n        maxLLDD = outCR$loglik\n     } else if(outDD1$conv == -1 & outDD2$conv != -1)\n     {\n        maxLLDD = outDD2$loglik\n     } else if(outDD1$conv != -1 & outDD2$conv == -1)\n     {\n        maxLLDD = outDD1$loglik\n     } else {\n        maxLLDD = max(outDD1$loglik,outDD2$loglik)\n     }   \n     LR = pmax(0,maxLLDD - outCR$loglik)\n     outff = cbind(1,mc,outCR,outDD1,outDD2,LR)\n     outff = outff[,-c(5,7,13,19)]     \n     names(outff) = newnames\n     out = rbind(out,outff)\n     if(!is.null(outputfilename))\n     {\n        save(seed,brts,out,treeCR,treeDD,file = outputfilename)\n     }\n  }\n  opt = rep(0,endmc)\n  cat('Performing bootstrap to determine power ...\\n')\n  for(mc in 1:endmc)\n  {\n     cat('Analyzing simulation:',mc,'\\n')\n     brtsDD = branching.times(treeDD[[mc]][[1]])\n     outCR = dd_ML(brtsDD,initparsopt = parsCR,idparsopt = 1:2, idparsfix = 3,parsfix = Inf,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     outDD1 = dd_ML(brtsDD,initparsopt = parsDD,idparsopt = 1:3,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     outDD2 = dd_ML(brtsDD,initparsopt = c(parsCR + 0.05,length(brts) + 1000), idparsopt = 1:3,res = res,ddmodel = ddmodel,missnumspec = missnumspec,cond = cond,btorph = btorph,soc = soc,tol = tol,maxiter = maxiter,changeloglikifnoconv = changeloglikifnoconv, optimmethod = optimmethod)\n     if(outDD1$conv == -1 & outDD2$conv == -1)\n     {\n        maxLLDD = outCR$loglik\n        opt[mc] = 1\n     } else if(outDD1$conv != -1 & outDD2$conv == -1)\n     {\n        maxLLDD = outDD1$loglik\n        opt[mc] = 2\n     } else if(outDD1$conv == -1 & outDD2$conv != -1)\n     {\n        maxLLDD = outDD2$loglik\n        opt[mc] = 3\n     } else {\n        maxLLDD = max(outDD1$loglik,outDD2$loglik)\n        opt[mc] = 1 + min(which(c(outDD1$loglik,outDD2$loglik) == maxLLDD))\n     }\n     LR = pmax(0,maxLLDD - outCR$loglik)\n     outff = cbind(1,mc,outCR,outDD1,outDD2,LR)\n     outff = outff[,-c(5,7,13,19)]\n     names(outff) = newnames\n     out = rbind(out,outff)\n     if(!is.null(outputfilename))\n     {\n        save(seed,brts,out,opt,treeCR,treeDD,file = outputfilename)\n     }\n  }\n  inverse_quantile = function(samples,x)\n  {\n     samplessort = sort(samples)\n     pup = which(samplessort > x)\n     if(length(pup) > 0)\n     {\n        if(length(pup) < length(samplessort))\n        {\n           pup = min(pup)\n           invquant = (pup + (x - samplessort[pup])/(samplessort[pup - 1] - samplessort[pup]))/length(samples)\n        } else {\n           invquant = 0\n        }\n     } else {\n        invquant = 1\n     }\n     return(invquant)\n  }\n  funpvalue = function(samples,x)\n  {\n     samplessort = sort(samples)\n     pup = which(samplessort > x)\n     pvalue = (length(pup) + 1)/ (length(samples) + 1)\n     return(pvalue)\n  }\n  funpoweroftest = function(samples,x)\n  {\n     samplessort = sort(samples)\n     pup = which(samplessort > x)\n     poweroftest = length(pup)/(length(samples) + 1)\n     return(poweroftest)     \n  }\n  #pvalue = 1 - inverse_quantile(out$LR[2:(endmc + 1)],out$LR[1])\n  pvalue = funpvalue(out$LR[2:(endmc + 1)],out$LR[1])\n  LRalpha = as.numeric(quantile(out$LR[2:(endmc + 1)],1 - alpha,type = 4))\n  #poweroftest = 1 - inverse_quantile(out$LR[(endmc + 2):(2 * endmc + 1)],LRalpha)\n  poweroftest = funpoweroftest(out$LR[(endmc + 2):(2 * endmc + 1)],LRalpha)\n  if(plotit == TRUE)\n  {\n      try(dev.off())\n      try(dev.off())\n      pdffilename = paste(getwd(),'/LR.pdf',sep = '')\n      pdf(pdffilename,paper = \"a4r\", width = 29.7, height = 21)\n      al = 0.03\n      alw = 2\n      alw2 = 1.7\n      aa = 45\n      par(mfrow = c(2,2),cex = 1, mar = c(5, 4, 3, 1) + 0.1)\n      hist(out$LR[2:(1 + endmc)],main = 'Distribution of LLR under CR',xlab = 'LLR', ylab = 'Frequency', col = 'red',probability = T,nclass = 30, xlim = c(0,max(out$LR[1:(endmc + 1)])))\n      arrows(out$LR[1],-1E+120, x1 = out$LR[1],y1 = 0, length = al, angle = aa,lwd = alw, col = 'black')\n      arrows(LRalpha,-1E+120, x1 = LRalpha,y1 = 0, length = al, angle = aa,lwd = alw, col = 'blue')\n      box()\n      plot(0, 0, type = \"n\", bty = \"n\", xaxt = \"n\", yaxt = \"n\", col = \"white\", col.lab = 'white', col.axis = 'white')\n      hist(out$LR[(endmc + 2):(1 + 2 * endmc)], main = 'Distribution of LLR under DD',xlab = 'LLR', ylab = 'Frequency', col = 'red',probability = T,nclass = 30)\n      box()\n      arrows(out$LR[1],-1E+120, x1 = out$LR[1],y1 = 0, length = al, angle = aa,lwd = alw, col = 'black')\n      arrows(LRalpha,-1E+120, x1 = LRalpha,y1 = 0, length = al, angle = aa,lwd = alw, col = 'blue')\n\n      par(mfrow = c(2,3),cex = 1, mar = c(5, 4, 3, 1) + 0.1)\n      lambda = out$lambda_CR[(endmc + 2):(2 * endmc + 1)] * (opt == 1) + out$lambda_DD1[(endmc + 2):(2 * endmc + 1)] * (opt == 2) + out$lambda_DD2[(endmc + 2):(2 * endmc + 1)] * (opt == 3)\n      mu = out$mu_CR[(endmc + 2):(2 * endmc + 1)] * (opt == 1) + out$mu_DD1[(endmc + 2):(2 * endmc + 1)] * (opt == 2) + out$mu_DD2[(endmc + 2):(2 * endmc + 1)] * (opt == 3)\n      K = 1E+120 * (opt == 1) + pmin(1E+120,out$K_DD1[(endmc + 2):(2 * endmc + 1)]) * (opt == 2) + pmin(1E+120,out$K_DD2[(endmc + 2):(2 * endmc + 1)]) * (opt == 3)\n      hist(lambda,main = NULL, xlab = expression(lambda), ylab = 'Frequency', col = 'red',probability = T,nclass = 30, xlim = c(0,max(lambda)))\n      arrows(out$lambda_DD1[1],-1E+120, x1 = out$lambda_DD1[1],y1 = 0, length = al, angle = aa,lwd = alw2, col = 'black')\n      box()\n      hist(mu,main = NULL, xlab = expression(mu), ylab = 'Frequency', col = 'red',probability = T,nclass = 30, xlim = c(0,max(mu)))\n      arrows(out$mu_DD1[1],-1E+120, x1 = out$mu_DD1[1],y1 = 0, length = al, angle = aa,lwd = alw2, col = 'black')\n      box()\n      hist(K,main = NULL, xlab = 'K', ylab = 'Frequency', col = 'red',probability = T,nclass = 30, xlim = c(min(K),max(K)))\n      arrows(out$K_DD1[1],-1E+120, x1 = out$K_DD1[1],y1 = 0, length = al, angle = aa,lwd = alw2, col = 'black')\n      box()\n      try(dev.off())\n      try(dev.off())\n      os = .Platform$OS.type\n      if(os == \"windows\")\n      {\n          shell.exec(pdffilename)\n      }\n      if(os == \"unix\")\n      {\n          system(paste(\"open\",pdffilename,sep = \" \"))\n      }\n  }\n  if(!is.null(outputfilename))\n  {\n      save(seed,brts,out,opt,treeCR,treeDD,pvalue,LRalpha,poweroftest,file = outputfilename)\n  }\n  return(list(treeCR = treeCR,treeDD = treeDD,out = out,pvalue = pvalue,LRalpha = LRalpha,poweroftest = poweroftest))\n}",
    "created" : 1478516524691.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1859994180",
    "id" : "2B34415F",
    "lastKnownWriteTime" : 1467114480,
    "last_content_update" : 1467114480,
    "path" : "D:/data/Ms/DDD/DDD/R/dd_LR.R",
    "project_path" : "R/dd_LR.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}