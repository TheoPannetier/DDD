}
ML <- function(initparsopt,idparsopt,parsfix,idparsfix,datamatrix,time_effect = 0,tol = c(1E-3, 1E-4, 1E-6),maxiter = 1000 * round((1.25)^2),optimmethod = 'simplex')
{
out2err <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, loglik = NA, df = length(initparsopt), conv = NA)
out2err <- invisible(out2err)
idpars = sort(c(idparsopt,idparsfix))
if((prod(idpars == (1:5)) != 1) || (length(initparsopt) != length(idparsopt)) || (length(parsfix) != length(idparsfix)))
{
cat("The parameters to be optimized and/or fixed are incoherent.\n")
return(out2err)
}
namepars <- c("a0 (r)","a1","b0 (K)","b1","disp")
if(length(namepars[idparsopt]) == 0) { optstr = "nothing" } else { optstr = namepars[idparsopt] }
cat("You are optimizing",optstr,"\n")
if(length(namepars[idparsfix]) == 0) { fixstr = "nothing" } else { fixstr = namepars[idparsfix] }
cat("You are fixing",fixstr,"\n")
trparsopt <- initparsopt/(1 + initparsopt)
trparsopt[which(initparsopt == Inf)] <- 1
trparsfix <- parsfix/(1 + parsfix)
trparsfix[which(parsfix == Inf)] = 1
optimpars <- c(tol,maxiter)
initloglik <- loglik_choosepar(trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
cat("The loglikelihood for the initial parameter values is",initloglik,"\n")
flush.console()
if(initloglik == -Inf)
{
cat("The initial parameter values have a likelihood that is equal to 0 or below machine precision. Try again with different initial values.\n")
out2 <- out2err
} else {
out <- DDD::optimizer(optimmethod = optimmethod,optimpars = optimpars,fun = loglik_choosepar,trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
if(out$conv != 0)
{
cat("Optimization has not converged. Try again with different initial values.\n")
out2 = out2err; out2$conv = unlist(out$conv)
} else
{
MLtrpars <- as.numeric(unlist(out$par))
MLpars <- MLtrpars/(1 - MLtrpars)
ML <- as.numeric(unlist(out$fvalues))
MLpars1 <- rep(0,5)
MLpars1[idparsopt] <- MLpars
if(length(idparsfix) != 0) { MLpars1[idparsfix] <- parsfix }
if(MLpars1[5] > 10^7){ MLpars1[5] <- Inf }
if(unlist(out$conv) != 0)
{
out2 <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, disp = NA, loglik = NA, df = length(initparsopt), conv = unlist(out$conv))
} else {
out2 <- data.frame(a0 = MLpars1[1], a1 = MLpars1[2], b0 = MLpars1[3], b1 = MLpars1[4], disp = MLpars1[5], loglik = ML, df = length(initparsopt), conv = unlist(out$conv))
}
}
}
return(out2)
}
comparemodels <- function(parsset,datamatrix,time_effect = 0,optimmethod = 'subplex',tol = c(1E-3, 1E-4, 1E-6))
{
out <- NULL
modellist <- list(c(1,3,5),c(1,2,3,5),c(1,3,4,5),c(1,2,3,4,5),c(2,3,5))
for(mod in 1:5)
{
idparsopt <- modellist[[mod]]
idparsfix <- (1:5)[-idparsopt]
initparsopt <- parsset[idparsopt]
parsfix <- rep(0,length(idparsfix))
out <- rbind(out,ML(initparsopt,idparsopt,parsfix,idparsfix,datamatrix = datamatrix,time_effect = time_effect,optimmethod = optimmethod, tol = tol))
}
k <- out$df
aic <- 2 * k - 2 * out$loglik
#aicc <- aic + 2 * (k^2 + k)/(nrow(datamatrix) - k - 1)
daic <- aic - min(aic)
waic <- exp(-daic/2); waic <- waic/sum(waic);
pv <- 1 - pchisq(2 * (out$loglik - out$loglik[1]),out$df - out$df[1])
out <- cbind(out,aic,daic,waic,pv)
return(out)
}
datamatrix <- read.csv("d:/data/ms/Ecodataset.csv",header = TRUE,sep = ";")
datamatrix <- subset(datamatrix,fitness != "NA") #remove ?islands? for which no fitness data is available
datamatrixD <- subset(datamatrix,days > 120) #remove all data before days == 120
datamatrixLI <- subset(datamatrix,days > 120 & numplants == 4) #only use 4 plants
datamatrixS <- subset(datamatrix,days > 120 & experiment == "Size") #data from island size experiment for plateau phase
datamatrixC <- subset(datamatrix,days > 100 & experiment == "Comp") #data from competition experiment for plateau phase
datamatrixL <- subset(datamatrix,days >= 174) #last 4 time points
datamatrixsel <- datamatrixL
time_effect <- 0
parsset1 <- c(0.5,0.1,50,0.1,10);
out1 <- comparemodels(parsset = parsset1,datamatrix = datamatrixsel,time_effect = time_effect)
parsset2 <- c(1,0.2,150,0.3,0.5);
out2 <- comparemodels(parsset = parsset2,datamatrix = datamatrixsel,time_effect = time_effect)
parsset3 <- c(1,2,150,0.3,0.5);
out3 <- comparemodels(parsset = parsset3,datamatrix = datamatrixsel,time_effect = time_effect)
parsset4 <- c(1.1,10,150,0.3,5);
out4 <- comparemodels(parsset = parsset4,datamatrix = datamatrixsel,time_effect = time_effect,tol = c(1E-5, 1E-6, 1E-7))
out1
library(DDD)
distmean <- function(pars,datamatrix,time_effect = 0)
{
Nt <- datamatrix$Nt
numplants <- datamatrix$numplants
alpha <- datamatrix$alpha
fitness <- datamatrix$fitness
days <- datamatrix$days
totaldays <- max(datamatrix$days)
r <- pars[1] + pars[2] * (days/totaldays)^time_effect * fitness
K <- pars[3] + pars[4] * (days/totaldays)^time_effect * fitness
K2 <- K * numplants
beta <- (log(r) + log(K2 + alpha) - log(K2))/(K2 + alpha)
dm <- (r * (Nt + alpha)) * exp(-beta * (Nt + alpha))
return(dm)
}
loglik <- function(pars,datamatrix,time_effect = 0)
{
Ntplus1 <- datamatrix$Ntplus1
ll <- sum(dnbinom(x = Ntplus1, mu = distmean(pars = pars,datamatrix = datamatrix,time_effect = time_effect),size = pars[5], log = TRUE))
return(ll)
}
loglik_choosepar <- function(trparsopt,trparsfix,idparsopt,idparsfix,datamatrix,time_effect = 0)
{
trpars1 <- rep(0,5)
trpars1[idparsopt] <- trparsopt
trpars1[idparsfix] <- trparsfix
if(max(trpars1) > 1 || min(trpars1) < 0)
{
loglik1 <- -Inf
} else {
pars1 <- trpars1/(1 - trpars1)
loglik1 <- loglik(pars = pars1,datamatrix = datamatrix, time_effect = time_effect)
if(is.nan(loglik1) || is.na(loglik1) || loglik1 == Inf)
{
cat("There are parameter values used which cause numerical problems.\n")
loglik1 <- -Inf
}
}
return(loglik1)
}
ML <- function(initparsopt,idparsopt,parsfix,idparsfix,datamatrix,time_effect = 0,tol = c(1E-3, 1E-4, 1E-6),maxiter = 1000 * round((1.25)^2),optimmethod = 'simplex')
{
out2err <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, loglik = NA, df = length(initparsopt), conv = NA)
out2err <- invisible(out2err)
idpars = sort(c(idparsopt,idparsfix))
if((prod(idpars == (1:5)) != 1) || (length(initparsopt) != length(idparsopt)) || (length(parsfix) != length(idparsfix)))
{
cat("The parameters to be optimized and/or fixed are incoherent.\n")
return(out2err)
}
namepars <- c("a0 (r)","a1","b0 (K)","b1","disp")
if(length(namepars[idparsopt]) == 0) { optstr = "nothing" } else { optstr = namepars[idparsopt] }
cat("You are optimizing",optstr,"\n")
if(length(namepars[idparsfix]) == 0) { fixstr = "nothing" } else { fixstr = namepars[idparsfix] }
cat("You are fixing",fixstr,"\n")
trparsopt <- initparsopt/(1 + initparsopt)
trparsopt[which(initparsopt == Inf)] <- 1
trparsfix <- parsfix/(1 + parsfix)
trparsfix[which(parsfix == Inf)] = 1
optimpars <- c(tol,maxiter)
initloglik <- loglik_choosepar(trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
cat("The loglikelihood for the initial parameter values is",initloglik,"\n")
flush.console()
if(initloglik == -Inf)
{
cat("The initial parameter values have a likelihood that is equal to 0 or below machine precision. Try again with different initial values.\n")
out2 <- out2err
} else {
out <- DDD::optimizer(optimmethod = optimmethod,optimpars = optimpars,fun = loglik_choosepar,trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
if(out$conv != 0)
{
cat("Optimization has not converged. Try again with different initial values.\n")
out2 = out2err; out2$conv = unlist(out$conv)
} else
{
MLtrpars <- as.numeric(unlist(out$par))
MLpars <- MLtrpars/(1 - MLtrpars)
ML <- as.numeric(unlist(out$fvalues))
MLpars1 <- rep(0,5)
MLpars1[idparsopt] <- MLpars
if(length(idparsfix) != 0) { MLpars1[idparsfix] <- parsfix }
if(MLpars1[5] > 10^7){ MLpars1[5] <- Inf }
if(unlist(out$conv) != 0)
{
out2 <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, disp = NA, loglik = NA, df = length(initparsopt), conv = unlist(out$conv))
} else {
out2 <- data.frame(a0 = MLpars1[1], a1 = MLpars1[2], b0 = MLpars1[3], b1 = MLpars1[4], disp = MLpars1[5], loglik = ML, df = length(initparsopt), conv = unlist(out$conv))
}
}
}
return(out2)
}
comparemodels <- function(parsset,datamatrix,time_effect = 0,optimmethod = 'subplex',tol = c(1E-3, 1E-4, 1E-6))
{
out <- NULL
modellist <- list(c(1,3,5),c(1,2,3,5),c(1,3,4,5),c(1,2,3,4,5),c(2,3,5))
for(mod in 1:5)
{
idparsopt <- modellist[[mod]]
idparsfix <- (1:5)[-idparsopt]
initparsopt <- parsset[idparsopt]
parsfix <- rep(0,length(idparsfix))
out <- rbind(out,ML(initparsopt,idparsopt,parsfix,idparsfix,datamatrix = datamatrix,time_effect = time_effect,optimmethod = optimmethod, tol = tol))
}
k <- out$df
aic <- 2 * k - 2 * out$loglik
#aicc <- aic + 2 * (k^2 + k)/(nrow(datamatrix) - k - 1)
daic <- aic - min(aic)
waic <- exp(-daic/2); waic <- waic/sum(waic);
pv <- 1 - pchisq(2 * (out$loglik - out$loglik[1]),out$df - out$df[1])
out <- cbind(out,aic,daic,waic,pv)
return(out)
}
datamatrix <- read.csv("d:/data/ms/Ecodataset.csv",header = TRUE,sep = ";")
datamatrix <- subset(datamatrix,fitness != "NA") #remove ?islands? for which no fitness data is available
datamatrixD <- subset(datamatrix,days > 120) #remove all data before days == 120
datamatrixLI <- subset(datamatrix,days > 120 & numplants == 4) #only use 4 plants
datamatrixS <- subset(datamatrix,days > 120 & experiment == "Size") #data from island size experiment for plateau phase
datamatrixC <- subset(datamatrix,days > 100 & experiment == "Comp") #data from competition experiment for plateau phase
datamatrixL <- subset(datamatrix,days >= 174) #last 4 time points
datamatrixsel <- datamatrix
time_effect <- 1
parsset1 <- c(0.5,0.1,50,0.1,10);
out1 <- comparemodels(parsset = parsset1,datamatrix = datamatrixsel,time_effect = time_effect)
parsset2 <- c(1,0.2,150,0.3,0.5);
out2 <- comparemodels(parsset = parsset2,datamatrix = datamatrixsel,time_effect = time_effect)
parsset3 <- c(1,2,150,0.3,0.5);
out3 <- comparemodels(parsset = parsset3,datamatrix = datamatrixsel,time_effect = time_effect)
parsset4 <- c(1.1,10,150,0.3,5);
out4 <- comparemodels(parsset = parsset4,datamatrix = datamatrixsel,time_effect = time_effect,tol = c(1E-5, 1E-6, 1E-7))
out1
library(DDD)
distmean <- function(pars,datamatrix,time_effect = 0)
{
Nt <- datamatrix$Nt
numplants <- datamatrix$numplants
alpha <- datamatrix$alpha
fitness <- datamatrix$fitness
days <- datamatrix$days
totaldays <- max(datamatrix$days)
r <- pars[1] + pars[2] * (days/totaldays)^time_effect * fitness
K <- pars[3] + pars[4] * (days/totaldays)^time_effect * fitness
K2 <- K * numplants
beta <- (log(r) + log(K2 + alpha) - log(K2))/(K2 + alpha)
dm <- (r * (Nt + alpha)) * exp(-beta * (Nt + alpha))
return(dm)
}
loglik <- function(pars,datamatrix,time_effect = 0)
{
Ntplus1 <- datamatrix$Ntplus1
ll <- sum(dnbinom(x = Ntplus1, mu = distmean(pars = pars,datamatrix = datamatrix,time_effect = time_effect),size = pars[5], log = TRUE))
return(ll)
}
loglik_choosepar <- function(trparsopt,trparsfix,idparsopt,idparsfix,datamatrix,time_effect = 0)
{
trpars1 <- rep(0,5)
trpars1[idparsopt] <- trparsopt
trpars1[idparsfix] <- trparsfix
if(max(trpars1) > 1 || min(trpars1) < 0)
{
loglik1 <- -Inf
} else {
pars1 <- trpars1/(1 - trpars1)
loglik1 <- loglik(pars = pars1,datamatrix = datamatrix, time_effect = time_effect)
if(is.nan(loglik1) || is.na(loglik1) || loglik1 == Inf)
{
cat("There are parameter values used which cause numerical problems.\n")
loglik1 <- -Inf
}
}
return(loglik1)
}
ML <- function(initparsopt,idparsopt,parsfix,idparsfix,datamatrix,time_effect = 0,tol = c(1E-3, 1E-4, 1E-6),maxiter = 1000 * round((1.25)^2),optimmethod = 'simplex')
{
out2err <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, loglik = NA, df = length(initparsopt), conv = NA)
out2err <- invisible(out2err)
idpars = sort(c(idparsopt,idparsfix))
if((prod(idpars == (1:5)) != 1) || (length(initparsopt) != length(idparsopt)) || (length(parsfix) != length(idparsfix)))
{
cat("The parameters to be optimized and/or fixed are incoherent.\n")
return(out2err)
}
namepars <- c("a0 (r)","a1","b0 (K)","b1","disp")
if(length(namepars[idparsopt]) == 0) { optstr = "nothing" } else { optstr = namepars[idparsopt] }
cat("You are optimizing",optstr,"\n")
if(length(namepars[idparsfix]) == 0) { fixstr = "nothing" } else { fixstr = namepars[idparsfix] }
cat("You are fixing",fixstr,"\n")
trparsopt <- initparsopt/(1 + initparsopt)
trparsopt[which(initparsopt == Inf)] <- 1
trparsfix <- parsfix/(1 + parsfix)
trparsfix[which(parsfix == Inf)] = 1
optimpars <- c(tol,maxiter)
initloglik <- loglik_choosepar(trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
cat("The loglikelihood for the initial parameter values is",initloglik,"\n")
flush.console()
if(initloglik == -Inf)
{
cat("The initial parameter values have a likelihood that is equal to 0 or below machine precision. Try again with different initial values.\n")
out2 <- out2err
} else {
out <- DDD::optimizer(optimmethod = optimmethod,optimpars = optimpars,fun = loglik_choosepar,trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
if(out$conv != 0)
{
cat("Optimization has not converged. Try again with different initial values.\n")
out2 = out2err; out2$conv = unlist(out$conv)
} else
{
MLtrpars <- as.numeric(unlist(out$par))
MLpars <- MLtrpars/(1 - MLtrpars)
ML <- as.numeric(unlist(out$fvalues))
MLpars1 <- rep(0,5)
MLpars1[idparsopt] <- MLpars
if(length(idparsfix) != 0) { MLpars1[idparsfix] <- parsfix }
if(MLpars1[5] > 10^7){ MLpars1[5] <- Inf }
if(unlist(out$conv) != 0)
{
out2 <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, disp = NA, loglik = NA, df = length(initparsopt), conv = unlist(out$conv))
} else {
out2 <- data.frame(a0 = MLpars1[1], a1 = MLpars1[2], b0 = MLpars1[3], b1 = MLpars1[4], disp = MLpars1[5], loglik = ML, df = length(initparsopt), conv = unlist(out$conv))
}
}
}
return(out2)
}
comparemodels <- function(parsset,datamatrix,time_effect = 0,optimmethod = 'subplex',tol = c(1E-3, 1E-4, 1E-6))
{
out <- NULL
modellist <- list(c(1,3,5),c(1,2,3,5),c(1,3,4,5),c(1,2,3,4,5),c(2,3,5))
for(mod in 1:5)
{
idparsopt <- modellist[[mod]]
idparsfix <- (1:5)[-idparsopt]
initparsopt <- parsset[idparsopt]
parsfix <- rep(0,length(idparsfix))
out <- rbind(out,ML(initparsopt,idparsopt,parsfix,idparsfix,datamatrix = datamatrix,time_effect = time_effect,optimmethod = optimmethod, tol = tol))
}
k <- out$df
aic <- 2 * k - 2 * out$loglik
#aicc <- aic + 2 * (k^2 + k)/(nrow(datamatrix) - k - 1)
daic <- aic - min(aic)
waic <- exp(-daic/2); waic <- waic/sum(waic);
pv <- 1 - pchisq(2 * (out$loglik - out$loglik[1]),out$df - out$df[1])
out <- cbind(out,aic,daic,waic,pv)
return(out)
}
datamatrix <- read.csv("d:/data/ms/Ecodataset.csv",header = TRUE,sep = ";")
datamatrix <- subset(datamatrix,fitness != "NA") #remove ?islands? for which no fitness data is available
datamatrixD <- subset(datamatrix,days > 120) #remove all data before days == 120
datamatrixDLI <- subset(datamatrix,days > 120 & numplants == 4) #only use 4 plants
datamatrixDS <- subset(datamatrix,days > 120 & experiment == "Size") #data from island size experiment for plateau phase
datamatrixDC <- subset(datamatrix,days > 100 & experiment == "Comp") #data from competition experiment for plateau phase
datamatrixL <- subset(datamatrix,days >= 174) #last 4 time points
datamatrixLS <- subset(datamatrix,days >= 174 & experiment == "Size") #last 4 time points from island size experiment
datamatrixLC <- subset(datamatrix,days >= 174 & experiment == "Comp") #last 4 time points from competition experiment
datamatrixsel <- datamatrixLS
time_effect <- 0
parsset1 <- c(0.5,0.1,50,0.1,10);
out1 <- comparemodels(parsset = parsset1,datamatrix = datamatrixsel,time_effect = time_effect)
parsset2 <- c(1,0.2,150,0.3,0.5);
out2 <- comparemodels(parsset = parsset2,datamatrix = datamatrixsel,time_effect = time_effect)
parsset3 <- c(1,2,150,0.3,0.5);
out3 <- comparemodels(parsset = parsset3,datamatrix = datamatrixsel,time_effect = time_effect)
parsset4 <- c(1.1,10,150,0.3,5);
out4 <- comparemodels(parsset = parsset4,datamatrix = datamatrixsel,time_effect = time_effect,tol = c(1E-5, 1E-6, 1E-7))
out1
library(DDD)
distmean <- function(pars,datamatrix,time_effect = 0)
{
Nt <- datamatrix$Nt
numplants <- datamatrix$numplants
alpha <- datamatrix$alpha
fitness <- datamatrix$fitness
days <- datamatrix$days
totaldays <- max(datamatrix$days)
r <- pars[1] + pars[2] * (days/totaldays)^time_effect * fitness
K <- pars[3] + pars[4] * (days/totaldays)^time_effect * fitness
K2 <- K * numplants
beta <- (log(r) + log(K2 + alpha) - log(K2))/(K2 + alpha)
dm <- (r * (Nt + alpha)) * exp(-beta * (Nt + alpha))
return(dm)
}
loglik <- function(pars,datamatrix,time_effect = 0)
{
Ntplus1 <- datamatrix$Ntplus1
ll <- sum(dnbinom(x = Ntplus1, mu = distmean(pars = pars,datamatrix = datamatrix,time_effect = time_effect),size = pars[5], log = TRUE))
return(ll)
}
loglik_choosepar <- function(trparsopt,trparsfix,idparsopt,idparsfix,datamatrix,time_effect = 0)
{
trpars1 <- rep(0,5)
trpars1[idparsopt] <- trparsopt
trpars1[idparsfix] <- trparsfix
if(max(trpars1) > 1 || min(trpars1) < 0)
{
loglik1 <- -Inf
} else {
pars1 <- trpars1/(1 - trpars1)
loglik1 <- loglik(pars = pars1,datamatrix = datamatrix, time_effect = time_effect)
if(is.nan(loglik1) || is.na(loglik1) || loglik1 == Inf)
{
cat("There are parameter values used which cause numerical problems.\n")
loglik1 <- -Inf
}
}
return(loglik1)
}
ML <- function(initparsopt,idparsopt,parsfix,idparsfix,datamatrix,time_effect = 0,tol = c(1E-3, 1E-4, 1E-6),maxiter = 1000 * round((1.25)^2),optimmethod = 'simplex')
{
out2err <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, loglik = NA, df = length(initparsopt), conv = NA)
out2err <- invisible(out2err)
idpars = sort(c(idparsopt,idparsfix))
if((prod(idpars == (1:5)) != 1) || (length(initparsopt) != length(idparsopt)) || (length(parsfix) != length(idparsfix)))
{
cat("The parameters to be optimized and/or fixed are incoherent.\n")
return(out2err)
}
namepars <- c("a0 (r)","a1","b0 (K)","b1","disp")
if(length(namepars[idparsopt]) == 0) { optstr = "nothing" } else { optstr = namepars[idparsopt] }
cat("You are optimizing",optstr,"\n")
if(length(namepars[idparsfix]) == 0) { fixstr = "nothing" } else { fixstr = namepars[idparsfix] }
cat("You are fixing",fixstr,"\n")
trparsopt <- initparsopt/(1 + initparsopt)
trparsopt[which(initparsopt == Inf)] <- 1
trparsfix <- parsfix/(1 + parsfix)
trparsfix[which(parsfix == Inf)] = 1
optimpars <- c(tol,maxiter)
initloglik <- loglik_choosepar(trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
cat("The loglikelihood for the initial parameter values is",initloglik,"\n")
flush.console()
if(initloglik == -Inf)
{
cat("The initial parameter values have a likelihood that is equal to 0 or below machine precision. Try again with different initial values.\n")
out2 <- out2err
} else {
out <- DDD::optimizer(optimmethod = optimmethod,optimpars = optimpars,fun = loglik_choosepar,trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,datamatrix = datamatrix,time_effect = time_effect)
if(out$conv != 0)
{
cat("Optimization has not converged. Try again with different initial values.\n")
out2 = out2err; out2$conv = unlist(out$conv)
} else
{
MLtrpars <- as.numeric(unlist(out$par))
MLpars <- MLtrpars/(1 - MLtrpars)
ML <- as.numeric(unlist(out$fvalues))
MLpars1 <- rep(0,5)
MLpars1[idparsopt] <- MLpars
if(length(idparsfix) != 0) { MLpars1[idparsfix] <- parsfix }
if(MLpars1[5] > 10^7){ MLpars1[5] <- Inf }
if(unlist(out$conv) != 0)
{
out2 <- data.frame(a0 = NA, a1 = NA, b0 = NA, b1 = NA, disp = NA, loglik = NA, df = length(initparsopt), conv = unlist(out$conv))
} else {
out2 <- data.frame(a0 = MLpars1[1], a1 = MLpars1[2], b0 = MLpars1[3], b1 = MLpars1[4], disp = MLpars1[5], loglik = ML, df = length(initparsopt), conv = unlist(out$conv))
}
}
}
return(out2)
}
comparemodels <- function(parsset,datamatrix,time_effect = 0,optimmethod = 'subplex',tol = c(1E-3, 1E-4, 1E-6))
{
out <- NULL
modellist <- list(c(1,3,5),c(1,2,3,5),c(1,3,4,5),c(1,2,3,4,5),c(2,3,5))
for(mod in 1:5)
{
idparsopt <- modellist[[mod]]
idparsfix <- (1:5)[-idparsopt]
initparsopt <- parsset[idparsopt]
parsfix <- rep(0,length(idparsfix))
out <- rbind(out,ML(initparsopt,idparsopt,parsfix,idparsfix,datamatrix = datamatrix,time_effect = time_effect,optimmethod = optimmethod, tol = tol))
}
k <- out$df
aic <- 2 * k - 2 * out$loglik
#aicc <- aic + 2 * (k^2 + k)/(nrow(datamatrix) - k - 1)
daic <- aic - min(aic)
waic <- exp(-daic/2); waic <- waic/sum(waic);
pv <- 1 - pchisq(2 * (out$loglik - out$loglik[1]),out$df - out$df[1])
out <- cbind(out,aic,daic,waic,pv)
return(out)
}
datamatrix <- read.csv("d:/data/ms/Ecodataset.csv",header = TRUE,sep = ";")
datamatrix <- subset(datamatrix,fitness != "NA") #remove ?islands? for which no fitness data is available
datamatrixD <- subset(datamatrix,days > 120) #remove all data before days == 120
datamatrixDLI <- subset(datamatrix,days > 120 & numplants == 4) #only use 4 plants
datamatrixDS <- subset(datamatrix,days > 120 & experiment == "Size") #data from island size experiment for plateau phase
datamatrixDC <- subset(datamatrix,days > 100 & experiment == "Comp") #data from competition experiment for plateau phase
datamatrixL <- subset(datamatrix,days >= 174) #last 4 time points
datamatrixLS <- subset(datamatrix,days >= 174 & experiment == "Size") #last 4 time points from island size experiment
datamatrixLC <- subset(datamatrix,days >= 174 & experiment == "Comp") #last 4 time points from competition experiment
datamatrixsel <- datamatrixLC
time_effect <- 0
parsset1 <- c(0.5,0.1,50,0.1,10);
out1 <- comparemodels(parsset = parsset1,datamatrix = datamatrixsel,time_effect = time_effect)
parsset2 <- c(1,0.2,150,0.3,0.5);
out2 <- comparemodels(parsset = parsset2,datamatrix = datamatrixsel,time_effect = time_effect)
parsset3 <- c(1,2,150,0.3,0.5);
out3 <- comparemodels(parsset = parsset3,datamatrix = datamatrixsel,time_effect = time_effect)
parsset4 <- c(1.1,10,150,0.3,5);
out4 <- comparemodels(parsset = parsset4,datamatrix = datamatrixsel,time_effect = time_effect,tol = c(1E-5, 1E-6, 1E-7))
out1
max(datamatrix$days,4)
?max
?largest
?large
ff = subset(datamatrix,experiment = "Comp")
max(ff$days)
unique(ff$days)
ff = subset(datamatrix,experiment = "size")
unique(ff$days)
ff = subset(datamatrix,experiment = "Size")
unique(ff$days)
(0.9)^0.1
(0.``)^0.1
(0.1)^0.1
(0.1)^2
(0.9)^2
(0.9)^10
(0.1)^10
(0.8)^10
(0.95)^10
