library(DDD)
L = dd_sim(c(0.2,0.1,40),10); L2phylo(L)
library(DDD)
L = dd_sim(c(0.2,0.1,40),10); L2phylo(L)
L2brts(L)
DDD::L2brts(L)
library(DDD)
L = dd_sim(c(0.2,0.1,40),10); L2phylo(L)
L
L2phylo(L)
L2phylo(L,dropextinct = T)
L
L = dd_sim(c(0.2,0.1,40),10)$L; L2phylo(L)
L = dd_sim(c(0.2,0.1,40),10)$L; branching.times(L2phylo(L))
L2brts(L)
library(DDD)
L = dd_sim(c(0.2,0.1,40),10)$L; branching.times(L2phylo(L))
L2brts(L)
library(DDD)
L = dd_sim(c(0.2,0.1,40),10)$L; branching.times(L2phylo(L))
L2brts(L)
library(DDD)
L = dd_sim(c(0.2,0.1,40),10)$L; branching.times(L2phylo(L))
L2brts(L)
L = dd_sim(c(0.2,0.1,40),10)$L; rev(sort(branching.times(L2phylo(L)))
L = dd_sim(c(0.2,0.1,40),10)$L; rev(sort(branching.times(L2phylo(L))))
L2brts(L)
L = dd_sim(c(0.2,0.1,40),10)$L; b1 = rev(sort(branching.times(L2phylo(L)))); b2 = L2brts(L)
b1
b2
b1 - b2
load('d:/data/ms/LtableGL.RData')
ls()
L
L
L2brts(L)
plot(L2phylo(L))
rm(list = ls())
load('d:/data/ms/LtableGL.RData')
L2brts(L)
?update.packages
load('d:/data/ms/LtableGL.RData')
L2brts(L)
L2phylo(L)
L
L2 = L
L2[14,2] = -2
L2[18,2] = -14
L2phylo(L2)
tes = L2phylo(L2)
plot(tree)
plot(tes)
?ode
ode
library(deSolve)
ode
subplex
?ICweights
libfrary(deSOlve)
library(deSOlve)
library(deSolve)
?ode
ll = list(a = 1,b = 2, c = 4)
length(ll)
ll = list(a = c(1,2),b = 2, c = 4)
length(ll)
expfun <- function(la,mu,t,t0)
{
res <- exp(-(la - mu) * (t - t0))
return(res)
}
logP0 <- function(la,mu,t0,t,f)
{
if(la > mu)
{
res <- log(mu) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusP0 <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
return(res)
}
logu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(la) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) + log(f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) + log(f) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
}
logu(la = c(0.1,0.2),mu = c(0.05,0.01),t = c(2,3),t0 = c(1,2))
logu(la = c(0.1,0.2),mu = c(0.05,0.01),t = c(2,3),t0 = c(1,2),f = NULL)
f = expfun(la = c(0.1,0.2),mu = c(0.05,0.01),t = c(2,3),t0 = c(1,2))
f
logu(la = c(0.1,0.2),mu = c(0.05,0.01),t = c(2,3),t0 = c(1,2),f = f)
ff = function(la,mu){(la < mu) * log(mu - la) + (la > mu) * log(la - mu)}
ff(la = c(0.1,0.2),mu = c(0.05,0.01))
ff
datalist
ll = list(a = c(1,2),b = 2, c = 4)
max(ll)
max(ll[,])
lapply(ll[1,],max)
lapply(ll,max)
lapply(ll,max)[[1]]
ll = list(a = c(20,15,3),b = c(20.1,19.1,3,2), c = c(4))
lapply(ll,max)[[1]]
lapply(ll,max)$b
lapply(ll,max)$a
lapply(ll,which.max)
dataparslist = list(matrix(0,3,10),matrix(1,3,10),matrix(2,3,10))
dataparslist
dataparslist[[3]][2,4] = 5
dataparslist[[2]][2,4] = 4
dataparslist[[1]][2,4] = 1.2
dataparslist
which.min.row.matrix <- function(mat,rownum)
{
return(which.min(mat[rownum,]))
}
which.min.row.matrix(dataparslist[[1]])
which.min.row.matrix(dataparslist[[2]])
which.min.row.matrix(dataparslist[[3]])
which.min.row.matrix(dataparslist[[3]])
dataparslist[[1]][1,1] = 10
which.min.row.matrix(dataparslist[[1]])
which.min.row.matrix(dataparslist[[1]],rownum = 1)
which.min.row.matrix(dataparslist[[1]],rownum = 2)
which.min.row.matrix(dataparslist[[1]],rownum = 3)
take.matrix.element <- function(mat,rownum = 1,colnum = 1)
{
return(mat[rownum,colnum])
}
cf <- lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1) #crown branch
CF
cf
cf <- which.min(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
cla
cf
dataparlist
dataparslist
dataparslist[[2]][1,1:10] = 1:10
dataparslist[[2]][1,1:10] = 10:1
dataparslist
dataparslist[[2]][2,1:10] = 20:11
dataparslist[[2]][2,1:10] = runif(10)
dataparslist
cf <- which.min(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
cf
cla
cf
dataparslist
dataparslist[[3]][2,1:10] = runif(10)
dataparslist[[3]][1,1:10] = 11:1
dataparslist[[3]][1,1:10] = 11:2
cf <- which.min(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
cf
cla
dataparslist[[1]][1,1:10] = 9:0
dataparslist[[3]][2,1:10] = runif(10)
cf <- which.min(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
cf
cla
dataparslist
dataparslist = -dataparslist
expfun <- function(la,mu,t,t0)
{
res <- exp(-(la - mu) * (t - t0))
return(res)
}
logP0 <- function(la,mu,t0,t,f)
{
if(la > mu)
{
res <- log(mu) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusP0 <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
return(res)
}
logu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(la) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) + log(f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) + log(f) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
return(res)
}
take.matrix.element <- function(mat,rownum = 1,colnum = 1)
{
return(mat[rownum,colnum])
}
#The data are assumed to be a list where every element
#of the list refers to a single broken fragment after
#the breaking the tree procedure of Nee et al. 1994
#Each element is a matrix with in the first row the
#branching times and shift times and in the second
#and third row the corresponding speciation and extinction
#rates. The speciation event that gave rise to the fragment
#is assumed to have the first set of rates.
SR_bd_loglik <- function(dataparslist,cond = NULL)
{
loglik <- 0
for(i in 1:length(dataparslist))
{
times <- c(-abs(dataparslist[[i]][1,]),0)
la <- dataparslist[[i]][2,]
mu <- dataparslist[[i]][3,]
nj <- length(times) - 1
for(j in 1:nj)
{
f <- expfun(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j])
loglik <- loglik + log(la[j])
log1minusP0(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f) +
log1minusu(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f)
if(j < nj)
{
f2 <- expfun(la = la[j],mu = mu[j],t = times[j + 2],t0 = times[j + 1])
loglik <- loglik - log(1 - exp(
logu(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f)
+ logP0(la = la[j],mu = mu[j],t = times[j + 2],t0 = times[j + 1],f = f2)
))
}
}
}
if(cond == 'crown_split')
{
cf <- which.max(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
loglik <- loglik - log(cla) #remove crown lineage
}
return(loglik)
}
SR_bd_loglik(dataparslist)
expfun <- function(la,mu,t,t0)
{
res <- exp(-(la - mu) * (t - t0))
return(res)
}
logP0 <- function(la,mu,t0,t,f)
{
if(la > mu)
{
res <- log(mu) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusP0 <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
return(res)
}
logu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la) + log(1 - f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(la) + log(f - 1) - log(mu * f - la)
} else
{
res <- log(mu) + log(t - t0) - log(1 + mu * (t - t0))
}
return(res)
}
log1minusu <- function(la,mu,t,t0,f)
{
if(la > mu)
{
res <- log(la - mu) + log(f) - log(la - mu * f)
} else if(la < mu)
{
res <- log(mu - la) + log(f) - log(mu * f - la)
} else
{
res <- -log(1 + mu * (t - t0))
}
return(res)
}
take.matrix.element <- function(mat,rownum = 1,colnum = 1)
{
return(mat[rownum,colnum])
}
#The data are assumed to be a list where every element
#of the list refers to a single broken fragment after
#the breaking the tree procedure of Nee et al. 1994
#Each element is a matrix with in the first row the
#branching times and shift times and in the second
#and third row the corresponding speciation and extinction
#rates. The speciation event that gave rise to the fragment
#is assumed to have the first set of rates.
SR_bd_loglik <- function(dataparslist,cond = NULL)
{
loglik <- 0
for(i in 1:length(dataparslist))
{
times <- c(-abs(dataparslist[[i]][1,]),0)
la <- dataparslist[[i]][2,]
mu <- dataparslist[[i]][3,]
nj <- length(times) - 1
for(j in 1:nj)
{
f <- expfun(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j])
loglik <- loglik + log(la[j])
log1minusP0(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f) +
log1minusu(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f)
if(j < nj)
{
f2 <- expfun(la = la[j],mu = mu[j],t = times[j + 2],t0 = times[j + 1])
loglik <- loglik - log(1 - exp(
logu(la = la[j],mu = mu[j],t = times[j + 1],t0 = times[j],f = f)
+ logP0(la = la[j],mu = mu[j],t = times[j + 2],t0 = times[j + 1],f = f2)
))
}
}
}
if(cond == 1)
{
cf <- which.max(unlist(lapply(dataparslist,take.matrix.element, rownum = 1,colnum = 1))) #crown branch
cla <- dataparslist[[cf]][2,1]
loglik <- loglik - log(cla) #remove crown lineage
}
return(loglik)
}
SR_bd_loglik(dataparslist)
SR_bd_loglik(dataparslist,cond = 0)
dataparslist
dataparslist[[1]][2,1:10] = runif(10)
SR_bd_loglik(dataparslist,cond = 0)
SR_bd_loglik(dataparslist,cond = 1)
library(BAMMtools)
library("ape", lib.loc="C:/Program Files/R/R-devel/library")
install.packages("ape")
library(DDD)
library(ape)
install.packages("ape")
install.packages("ape")
install.packages("ape")
install.packages("ape")
install.packages("ape")
install.packages("ape")
install.packages("C:/Users/rampa/Downloads/ape_4.1.zip", repos = NULL, type = "win.binary")
install.packages("C:/Users/rampa/Downloads/ape_4.0.tar.gz", repos = NULL, type = "source")
library(ape)
library(DDD)
