{
    "contents" : "lambdamu = function(n,pars,ddep)\n{\n    lnn = length(n)\n    zeros = rep(0,lnn)\n    ones = rep(1,lnn)\n    la = pars[1]\n    mu = pars[2]\n    K = pars[3]\n    r = pars[4]\n    lavec = la * ones\n    muvec = mu * ones\n    n0 = (ddep == 2 | ddep == 4)\n    if(ddep == 1)\n    {\n       Kprime = la / (la - mu) * K\n       lavec = pmax(zeros,la * (1 - n/Kprime))\n    } else if(ddep == 1.3)\n    {\n       lavec = pmax(zeros,la * (1 - n/K))\n    } else if(ddep == 2 | ddep == 2.1 | ddep == 2.2)\n    {\n       y = -(log(la/mu)/log(K+n0))^(ddep != 2.2)\n       lavec = pmax(zeros,la * (n + n0)^y)\n    } else if(ddep == 2.3)\n    {\n       y = K\n       lavec = pmax(zeros,la * (n + n0)^y)\n    } else if(ddep == 3)\n    {\n       lavec = la * ones\n       muvec = mu + (la - mu) * n/K\n    } else if(ddep == 4 | ddep == 4.1 | ddep == 4.2)\n    {\n       y = (log(la/mu)/log(K+n0))^(ddep != 4.2)\n       muvec = mu * (n + n0)^y\n    } else if(ddep == 5)\n    { \n       lavec = pmax(zeros,la - 1/(r + 1)*(la - mu)/K * n)\n       muvec = muvec = mu + r/(r + 1)*(la - mu)/K * n\n    }\n    return(list(lavec,muvec))\n}\n\ndd_loglik_M_aux = function(pars,lx,k,ddep)\n{\n    nvec = 0:(lx - 1);\n    lambdamu_nk = lambdamu(nvec + k,pars,ddep)\n    lambda_nk = lambdamu_nk[[1]]\n    mu_nk = lambdamu_nk[[2]];\n    i1 = 2:lx; j1 = 1:(lx - 1); x1 = lambda_nk[1:(lx - 1)] * (nvec[1:(lx - 1)] + 2 * k)\n    i2 = 1:(lx - 1); j2 = 2:lx; x2 = mu_nk[2:lx] * nvec[2:lx];\n    i3 = 1:lx; j3 = i3; x3 = -(lambda_nk + mu_nk) * (nvec + k)\n    MM = Matrix::sparseMatrix(i = c(i1,i2,i3),j = c(j1,j2,j3),x = c(x1,x2,x3), dims = c(lx,lx));\n    MM[lx,lx] = -mu_nk[lx] * (nvec[lx] + k)\n    return(MM)\n}\n\nchangepars = function(pars)\n{\n    if(length(pars) <= 3)\n    {\n       sel = 1:2\n    } else {\n       sel = c(1:2,4:5)\n    }\n    if(sum(pars[sel] == Inf) > 0)\n    {\n       pars[which(pars[sel] == Inf)] = 1E+10\n    }\n    if(sum(pars[sel] == 0) > 0)\n    {\n       pars[which(pars[sel] == 0)] = 1E-14\n    }\n    if(sum(pars[sel] == 1) > 0)\n    {\n       pars[which(pars[sel] == 1)] = pars[which(pars[sel] == 1)] - 1E-14\n    }\n    return(pars)\n}\n\ndd_loglik_M = function(pars,lx,k,ddep,tt,p)\n{\n    pars = changepars(pars)\n    MM = dd_loglik_M_aux(pars,lx,k,ddep)\n    p = expoRkit::expv(x = MM,v = p,t = tt,m = 50L)\n    return(p)\n}\n\ndd_loglik_M_bw_aux = function(pars,lx,k,ddep)\n{\n    nvec = 0:(lx - 1);\n    lambdamu_nk = lambdamu(nvec + k,pars,ddep)\n    lambda_nk = lambdamu_nk[[1]]\n    mu_nk = lambdamu_nk[[2]];\n    i1 = 2:lx; j1 = 1:(lx - 1); x1 = mu_nk[1:(lx - 1) + 1] * nvec[1:(lx - 1) + 1];\n    i2 = 1:(lx - 1); j2 = 2:lx; x2 = lambda_nk[2:lx - 1] * (nvec[2:lx] + 2 * k - 1);\n    i3 = 1:lx; j3 = i3; x3 = -(lambda_nk + mu_nk) * (nvec + k)\n    MM = Matrix::sparseMatrix(i = c(i1,i2,i3),j = c(j1,j2,j3),x = c(x1,x2,x3), dims = c(lx,lx));\n    MM[lx,lx] = -mu_nk[lx] * (nvec[lx] + k)\n    return(MM)\n}\n\ndd_loglik_M_bw = function(pars,lx,k,ddep,tt,p)\n{\n    pars = changepars(pars)\n    MM = dd_loglik_M_bw_aux(pars,lx,k,ddep)\n    p = expoRkit::expv(x = MM,v = p,t = tt,m = 50L)\n    return(p)\n}\n\nlambdamu2 = function(n,pars,ddep)\n{\n    lnn = length(n)\n    laM = pars[1]\n    muM = pars[2]\n    KM = pars[3]\n    n0 = (ddep == 2 | ddep == 4)\n    nx1 = rep(0:(lnn - 1),lnn)\n    dim(nx1) = c(lnn,lnn) # row index = number of species in first group \n    nx2 = t(nx1) # column index = number of species in second group\n    nxt = nx1 + nx2\n    if(ddep == 1) \n    { \n        lavec = pmax(matrix(0,lnn,lnn),laM - (laM-muM)/KM * nxt)\n        muvec = muM * matrix(1,lnn,lnn)\n    } else if(ddep == 1.3) \n    { \n        lavec = pmax(matrix(0,lnn,lnn),laM * (1 - nxt/KM))\n        muvec = muM * matrix(1,lnn,lnn)\n    } else if(ddep == 2 | ddep == 2.1 | ddep == 2.2)\n    { \n        x = -(log(laM/muM)/log(KM+n0))^(ddep != 2.2)\n        lavec = pmax(matrix(0,lnn,lnn),laM * (nxt + n0)^x)\n        muvec = muM * matrix(1,lnn,lnn)\n    } else if(ddep == 2.3)\n    { \n        x = KM\n        lavec = pmax(matrix(0,lnn,lnn),laM * (nxt + n0)^x)\n        muvec = muM * matrix(1,lnn,lnn)\n    } else if(ddep == 3)\n    {\n        lavec = laM * matrix(1,lnn,lnn)\n        muvec = muM + (laM - muM)/KM * nxt\n    } else if(ddep == 4 | ddep == 4.1 | ddep == 4.2)\n    {\n        lavec = laM * matrix(1,lnn,lnn)\n        x = (log(laM/muM)/log(KM+n0))^(ddep != 4.2)\n        muvec = (nxt + n0)^x\n    }\n    return(list(lavec,muvec))\n}\n\ndd_loglik_M2_aux = function(pars,lx,ddep)\n{\n    nvec = 0:(lx - 1);\n    lambdamu_n = lambdamu2(nvec,pars,ddep)\n    lambda_n = lambdamu_n[[1]]\n    mu_n = lambdamu_n[[2]];\n    ly = lx^2\n    # set elements\n    auxM1 = rep(0:(lx - 1),times = lx) + rep(0:(lx - 1),each = lx)\n    auxM2 = auxM1; auxM2[seq(lx,ly,by = lx)] = 0;\n    auxM3 = rep(1,ly); auxM3[seq(lx,ly,by = lx)] = 0;\n    # subdiagonal\n    i1 = 2:ly; j1 = 1:(ly - 1); x1 = lambda_n[1 + auxM1[1:(ly - 1)]] * (auxM2[1:(ly - 1)] > 0) * rep(0:(lx - 1),lx)[-ly];\n    # sublxdiagonal\n    i2 = (lx + 1):ly; j2 = 1:(ly - lx); x2 = lambda_n[1 + auxM1[1:(ly - lx)]] * (auxM2[1:(ly - lx)] > 0) * rep(0:(lx - 2),each = lx);\n    # superdiagonal\n    i3 = 1:(ly - 1); j3 = 2:ly; x3 = mu_n[1 + auxM1[2:ly]] * rep(0:(lx - 1), times = lx)[-1]; \n    # superlxdiagonal\n    i4 = 1:(ly - lx); j4 = (lx + 1):ly; x4 = (mu_n[1 + auxM1[1:ly]] * rep(0:(lx - 1),each = lx))[-c(1:lx)];\n    i5 = 1:ly; j5 = i5; x5 = -(lambda_n[1 + auxM1[1:ly]] + mu_n[1 + auxM1[1:ly]]) * auxM1[1:ly];\n    MM = Matrix::sparseMatrix(i = c(i1,i2,i3,i4,i5),j = c(j1,j2,j3,j4,j5),x = c(x1,x2,x3,x4,x5));\n    return(MM)\n}\n\ndd_loglik_M2 = function(pars,lx,ddep,tt,p)\n{\n    pars = changepars(pars)\n    MM = dd_loglik_M2_aux(pars,lx,ddep)\n    p = expoRkit::expv(x = MM,v = p,t = tt,m = 50L)\n    return(p)\n}\n\nlambdamu3 = function(n,pars,ddep,kM,kS)\n{\n    lnn = length(n) + kM + kS\n    laM = pars[1]\n    muM = pars[2]\n    K = pars[3]\n    laS = pars[4]\n    muS = pars[5]\n    n0 = (ddep == 2 | ddep == 4)\n    nx1 = rep(0:(lnn - 1),lnn)\n    dim(nx1) = c(lnn,lnn) # row index = number of species in first group \n    nx2 = t(nx1) # column index = number of species in second group\n    nxt = nx1 + nx2 + kM + kS\n    muvecM = muM * matrix(1,lnn,lnn)\n    muvecS = muS * matrix(1,lnn,lnn)    \n    if(ddep == 1.3) \n    { \n        lavecM = pmax(matrix(0,lnn,lnn),laM * (1 - nxt/K))\n        lavecS = pmax(matrix(0,lnn,lnn),laS * (1 - nxt/K))\n    } else if(ddep == 2.3)\n    { \n        x = K\n        lavecM = pmax(matrix(0,lnn,lnn),laM * (nxt + n0)^x)\n        lavecS = pmax(matrix(0,lnn,lnn),laS * (nxt + n0)^x)\n    }     \n    return(list(lavecM,muvecM,lavecS,muvecS))\n}\n\ndd_loglik_M3_aux = function(pars,lx,ddep,kM,kS)\n{\n    nvec = 0:(lx - 1);\n    lambdamu_n = lambdamu3(nvec,pars,ddep,kM,kS)\n    lambdaM_n = lambdamu_n[[1]]\n    muM_n = lambdamu_n[[2]];\n    lambdaS_n = lambdamu_n[[3]]\n    muS_n = lambdamu_n[[4]];\n    ly = lx^2\n    # set elements\n    auxM1 = rep(0:(lx - 1),times = lx) + rep(0:(lx - 1),each = lx)\n    auxM2 = auxM1; auxM2[seq(lx,ly,by = lx)] = 0;\n    auxM3 = rep(1,ly); auxM3[seq(lx,ly,by = lx)] = 0;\n    # subdiagonal\n    i1 = 2:ly; j1 = 1:(ly - 1); x1 = lambdaS_n[1 + auxM1[1:(ly - 1)]] * (kS + auxM2[1:(ly - 1)] > 0) * (rep(0:(lx - 1),lx)[-ly] + 2 * kS);\n    # sublxdiagonal\n    i2 = (lx + 1):ly; j2 = 1:(ly - lx); x2 = lambdaM_n[1 + auxM1[1:(ly - lx)]] * (kM + auxM2[1:(ly - lx)] > 0) * (rep(0:(lx - 2),each = lx) + 2 * kM);\n    # superdiagonal\n    i3 = 1:(ly - 1); j3 = 2:ly; x3 = muS_n[1 + auxM1[2:ly]] * rep(0:(lx - 1), times = lx)[-1];\n    # superlxdiagonal\n    i4 = 1:(ly - lx); j4 = (lx + 1):ly; x4 = (muM_n[1 + auxM1[1:ly]] * rep(0:(lx - 1),each = lx))[-c(1:lx)];\n    # diagonal\n    i5 = 1:ly; j5 = i5; x5 = -(lambdaM_n[1 + auxM1[1:ly]] + muM_n[1 + auxM1[1:ly]]) * (rep(0:(lx - 1),each = lx) + kM) - (lambdaS_n[1 + auxM1[1:ly]] + muS_n[1 + auxM1[1:ly]]) * (rep(0:(lx - 1),times = lx) + kS)\n    \n    MM = Matrix::sparseMatrix(i = c(i1,i2,i3,i4,i5),j = c(j1,j2,j3,j4,j5),x = c(x1,x2,x3,x4,x5));\n    return(MM)\n}\n\ndd_loglik_M3 = function(pars,lx,ddep,tt,p,kM,kS)\n{\n    pars = changepars(pars)\n    MM = dd_loglik_M3_aux(pars,lx,ddep,kM,kS)\n    p = expoRkit::expv(x = MM,v = p,t = tt,m = 50L)\n    return(p)\n}\n",
    "created" : 1450196039193.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2435803381",
    "id" : "DCD551B8",
    "lastKnownWriteTime" : 1450197515,
    "path" : "d:/data/Ms/DDD/R/dd_loglik_M.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}